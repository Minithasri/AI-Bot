/* eslint-disable react/no-unknown-property */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable prefer-const */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable prettier/prettier */
import React, { useEffect, useRef, useState, useMemo, useCallback } from "react";
import { AgGridReact } from "ag-grid-react";
import Domo from "ryuu.js";
import { useDispatch, useSelector } from "react-redux";
import { staffReqmtListRequest } from "@/redux/domo/staff-data/actions";
import { RootState } from "@/redux/store";
import toast from "react-hot-toast";
import Papa from "papaparse";
import { only } from "node:test";
import { MdArrowDropDown } from "react-icons/md";
import { FiEdit2 } from "react-icons/fi";

import "ag-grid-community/styles/ag-grid.css";
import "ag-grid-community/styles/ag-theme-alpine.css";

//  ADD THESE 2 LINES
import { ModuleRegistry, AllCommunityModule } from "ag-grid-community";

ModuleRegistry.registerModules([AllCommunityModule]);

const team_OPTIONS = ["Blue", "Purple", "Orange", "Pink", "Yellow", "Events", "Other"];
const reasons_OPTIONS = [
  "In ClientMajic, not posted",
  "Not invoiced",
  "Incorrect confirmation",
  "Incorrect cost",
  "Incorrect name on card",
  "Other",
];

const LoadingSpinner = () => (
  <div className="flex justify-center mt-16">
    <div className="animate-spin rounded-full h-14 w-14 border-t-4 border-purple-600"></div>
  </div>
);

/* ---------------- Simple Modal Component ---------------- */
const ConfirmModal: React.FC<{
  open: boolean;
  title?: string;
  message: string;
  onConfirm: () => void;
  onClose: () => void;
}> = ({ open, title = "Confirm", message, onConfirm, onClose }) => {
  if (!open) return null;
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="absolute inset-0 bg-black opacity-40" onClick={onClose} aria-hidden />
      <div className="relative bg-white rounded-lg shadow-xl max-w-lg w-full p-6 z-10">
        <h3 className="text-lg font-semibold mb-3">{title}</h3>
        <p className="text-sm text-gray-700 mb-6">{message}</p>

        <div className="flex justify-end gap-3">
          <button
            onClick={onClose}
            className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800"
          >
            Cancel
          </button>

          <button
            onClick={onConfirm}
            className="px-4 py-2 rounded-md bg-green-600 hover:bg-green-700 text-white"
          >
            YES
          </button>
        </div>
      </div>
    </div>
  );
};

const RecordsFetch: React.FC = () => {
  const dispatch = useDispatch();
  const { data: reduxData, loading } = useSelector((state: RootState) => state.staffReqmtList);
  console.log(reduxData, "reduxData-------");
  const [data, setData] = useState<any[]>([]);
  const [error, setError] = useState("");
  const [isSaving, setIsSaving] = useState(false);
  const [dataId, setDataId] = useState<any[]>([]);
  const [finalData, setFinalData] = useState<any[]>([]);
  const [onlyNames, setOnlyNames] = useState<any[]>([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalMessage, setModalMessage] = useState("");
  const [showEditable, setShowEditable] = useState(false);
  const [pendingCount, setPendingCount] = useState(0);
  const [updatedCount, setUpdatedCount] = useState(0);

  const gridRef = useRef<any>(null);
  const editedRowIdsRef = useRef<Set<string>>(new Set());
  const originalDataRef = useRef<any[] | null>(null);

  useEffect(() => {
    const fetchDatasetSavedRows = async () => {
      try {
        const res: any = await Domo.get(`/data/v1/modifiedData`);
        setDataId(res);
        console.log(res, "res------");
        return res;
      } catch (err) {
        console.error("Dataset fetch failed", err);
        return [];
      }
    };
    fetchDatasetSavedRows();
  }, []);

  useEffect(() => {
    const fetchDatasetSaved = async () => {
      try {
        const query = `SELECT Name FROM "Consultant Details" `;
        const nameDropdown: any = await Domo.post(`/data/v1/consultant`, {
          sql: query,
        });
        // const onlyNames = nameDropdown?.map((r: any) => r.Name) || [];
        // console.log(onlyNames, "names--");
        // setOnlyNames(onlyNames);

        const cleaned =
          nameDropdown?.map((r: any) => ({
            original: String(r.Name).trim(),
            key: String(r.Name).trim().toLowerCase(),
          })) || [];

        const uniqueNames = [...new Map(cleaned.map((x: any) => [x.key, x.original])).values()];

        setOnlyNames(uniqueNames);

        return nameDropdown;
      } catch (err) {
        console.error("Dataset fetch failed", err);
        return [];
      }
    };
    fetchDatasetSaved();
  }, []);
  useEffect(() => {
    dispatch(staffReqmtListRequest());
  }, [dispatch]);

  useEffect(() => {
    if (!Array.isArray(reduxData) || !Array.isArray(dataId)) return;
    if (reduxData.length === 0) return;

    const editableCols = ["invoiceId", "description", "team", "reasons", "Name"];
    const normalize = (v: any) => Number(v);

    const dataIdMap = new Map(dataId.map((row: any) => [normalize(row.row_number), row]));
    const mergedData: any[] = [];

    reduxData.forEach((row: any) => {
      const rowNum = normalize(row.row_number);
      const savedRow = dataIdMap.get(rowNum);

      if (savedRow) {
        const mergedRow: any = { ...row, ...savedRow };

        editableCols.forEach((col) => {
          if (savedRow[col] !== undefined && savedRow[col] !== null) {
            mergedRow[col] = savedRow[col];
          }
        });

        mergedData.push(mergedRow);
      } else {
        mergedData.push({ ...row });
      }
    });

    dataId.forEach((row: any) => {
      const rowNum = normalize(row.row_number);

      if (!reduxData.find((r) => normalize(r.row_number) === rowNum)) {
        const hasValue = editableCols.some(
          (col) => row[col] !== undefined && row[col] !== null && row[col].toString().trim() !== "",
        );

        if (hasValue) mergedData.push({ ...row });
      }
    });

    // ðŸ”¥ Fallback logic added
    const finalOutput = mergedData.length > 0 ? mergedData : reduxData;

    setFinalData([...finalOutput]); // force refresh for AgGrid
    originalDataRef.current = JSON.parse(JSON.stringify(finalOutput));
  }, [reduxData, dataId]);

  // const handleInputChange = useCallback((rowNumber: any, field: any, value: any) => {
  //   setFinalData((prev: any[]) => {
  //     const updated = prev.map((row: any) =>
  //       row.row_number === rowNumber ? { ...row, [field]: value } : row,
  //     );

  //     // Track edited rows
  //     if (originalDataRef.current) {
  //       const orig = originalDataRef.current.find((r) => r.row_number === rowNumber);

  //       const origVal = orig ? orig[field] ?? "" : "";

  //       if ((value ?? "").trim() !== (origVal ?? "").trim()) {
  //         editedRowIdsRef.current.add(rowNumber);
  //       } else {
  //         editedRowIdsRef.current.delete(rowNumber);
  //       }
  //     }

  //     return updated;
  //   });
  // }, []);
  const handleInputChange = useCallback((rowMeta: any, field: any, value: any) => {
    setFinalData((prev) => {
      const updated = prev.map((row) =>
        row.row_number === rowMeta.row_number &&
        row.upload_datetime === rowMeta.upload_datetime &&
        row.filename === rowMeta.filename &&
        row.sub_name === rowMeta.sub_name
          ? { ...row, [field]: value }
          : row,
      );

      if (originalDataRef.current) {
        const orig = originalDataRef.current.find(
          (r) =>
            r.row_number === rowMeta.row_number &&
            r.upload_datetime === rowMeta.upload_datetime &&
            r.filename === rowMeta.filename &&
            r.sub_name === rowMeta.sub_name,
        );

        const origVal = orig ? orig[field] ?? "" : "";

        if ((value ?? "").trim() !== (origVal ?? "").trim()) {
          editedRowIdsRef.current.add(JSON.stringify(rowMeta));
        } else {
          editedRowIdsRef.current.delete(JSON.stringify(rowMeta));
        }
      }

      return updated;
    });
  }, []);

  const handleSubmitClick = () => {
    setError("");
    const editedCount = editedRowIdsRef.current.size;
    if (editedCount > 0) {
      setModalMessage(
        `You have modified ${editedCount} row(s). Do you want to save these changes?`,
      );
    } else {
      setModalMessage("No fields were modified. Do you want to submit anyway?");
    }
    setIsModalOpen(true);
  };

  const handleConfirmSave = async () => {
    const idteam = "cbc63671-a11a-4680-8ae3-9b0dd7a68934"; // â˜… TEAM DATASET
    const removableCols = ["invoiceId", "description", "team", "reasons", "Name"];
    setIsModalOpen(false);

    try {
      setError("");
      setIsSaving(true);
      toast.loading("Saving data...");

      if (!finalData || finalData.length === 0) {
        toast.dismiss();
        setError("No data to upload!");
        setIsSaving(false);
        return;
      }

      // -----------------------------------------
      //  ORIGINAL MAIN DATASET LOGIC (UNCHANGED)
      // -----------------------------------------

      const dataColumns = Object.keys(reduxData[0] || {}).filter(
        (col) => !removableCols.includes(col),
      );

      const extraColumns = ["invoiceId", "description", "team", "reasons", "Name"];
      const DATASET_SCHEMA_ORDER = [...dataColumns, ...extraColumns];

      const cleanedData = finalData.map((row) => {
        const orderedRow: any = {};
        DATASET_SCHEMA_ORDER.forEach((col) => {
          orderedRow[col] =
            typeof row[col] === "string" ? row[col].replace(/[\r\n]+/g, " ") : row[col] ?? "";
        });
        return orderedRow;
      });

      const csv = Papa.unparse({
        fields: DATASET_SCHEMA_ORDER,
        data: cleanedData.map((row) => DATASET_SCHEMA_ORDER.map((col) => row[col])),
      });

      const datasetId = "8a8f1f7c-8a34-4495-844b-aba35cbd84ee";

      const isAllKeyFieldsEmpty = cleanedData.every((row) =>
        extraColumns.every((col) => !row[col] || row[col].toString().trim() === ""),
      );

      if (isAllKeyFieldsEmpty) {
        await Domo.post("/domo/codeengine/v2/packages/append", {
          dataset: datasetId,
          rows: csv.split("\n").slice(1),
          delimiter: ",",
        });
        toast.success("Data appended successfully!");
      } else {
        await Domo.post("/domo/codeengine/v2/packages/replace", {
          datasetId,
          rows: csv.split("\n").slice(1),
        });
        toast.success("Data replaced successfully!");
      }

      // -----------------------------------------
      // â˜… NEW REQUIREMENT: TEAM GROUPING LOGIC
      // -----------------------------------------

      // Group finalData by team and count
      const teamCounts: any = {};

      finalData.forEach((row) => {
        const team = row.team?.trim() || "Unknown";
        teamCounts[team] = (teamCounts[team] || 0) + 1;
      });

      const teamSummaryArray = Object.entries(teamCounts).map(([team, count]) => ({
        Team: team,
        Ticket_Count: count,
      }));

      // Convert to CSV (Team, Ticket_Count)
      const teamCSV = Papa.unparse({
        fields: ["Team", "Ticket_Count"],
        data: teamSummaryArray.map((r) => [r.Team, r.Ticket_Count]),
      });

      // Append or Replace using same condition logic
      if (isAllKeyFieldsEmpty) {
        await Domo.post("/domo/codeengine/v2/packages/append", {
          dataset: idteam,
          rows: teamCSV.split("\n").slice(1),
        });
        toast.success("Team data appended!");
      } else {
        await Domo.post("/domo/codeengine/v2/packages/replace", {
          datasetId: idteam,
          rows: teamCSV.split("\n").slice(1),
        });
        toast.success("Team data replaced!");
      }

      // -----------------------------------------

      // Reset tracking
      originalDataRef.current = finalData.map((r) => ({ ...r }));
      editedRowIdsRef.current = new Set();

      toast.dismiss();
    } catch (err) {
      console.error("âŒ Upload error:", err);
      setError("Upload failed. Check console.");
      toast.dismiss();
      toast.error("Upload failed.");
    } finally {
      setIsSaving(false);
      toast.dismiss();
    }
  };

  const columnDefs: any = useMemo(() => {
    if (!reduxData || reduxData.length === 0) return [];

    const removableCols = ["invoiceId", "description", "team", "reasons", "Name"];

    const baseColumns = Object.keys(reduxData[0] || {})
      .filter((col) => !removableCols.includes(col)) // prevent duplication
      .map((col) => ({
        field: col,
        headerName: col,
        floatingFilter: true,
        sortable: true,
        resizable: true,
        minWidth: 150,

        editable: false,
        cellStyle: { fontSize: "13px" },
      }));

    const DropdownCellRenderer = (props: any) => {
      return (
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            width: "100%",
            height: "100%",
            padding: "0 8px",
          }}
        >
          <span>{props.value || "Select"}</span>
          <MdArrowDropDown size={20} style={{ flexShrink: 0 }} />
        </div>
      );
    };

    // Custom cell renderer for text input cells
    const TextInputCellRenderer = (props: any) => {
      return (
        <div
          style={{
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            width: "100%",
            height: "100%",
            padding: "0 8px",
          }}
        >
          <span>{props.value || ""}</span>
          {!props.value && <FiEdit2 size={16} style={{ flexShrink: 0, opacity: 0.5 }} />}
        </div>
      );
    };

    const editableColumns = [
      {
        field: "invoiceId",
        headerName: "Invoice Id",
        editable: true,
        filter: "agTextColumnFilter",
        floatingFilter: true,
        sortable: true,
        resizable: true,
        minWidth: 150,
        cellRenderer: TextInputCellRenderer,
        cellStyle: { textAlign: "left", fontSize: "13px" },
        onCellValueChanged: (params: any) =>
          handleInputChange(
            {
              row_number: params.data.row_number,
              upload_datetime: params.data.upload_datetime,
              filename: params.data.filename,
              sub_name: params.data.sub_name,
            },
            "invoiceId",
            params.newValue,
          ),
      },

      {
        field: "description",
        headerName: "Description",
        filter: "agTextColumnFilter",
        floatingFilter: true,
        sortable: true,
        resizable: true,
        editable: true,
        minWidth: 200,
        cellRenderer: TextInputCellRenderer,
        cellStyle: { fontSize: "13px" },
        onCellValueChanged: (params: any) =>
          handleInputChange(
            {
              row_number: params.data.row_number,
              upload_datetime: params.data.upload_datetime,
              filename: params.data.filename,
              sub_name: params.data.sub_name,
            },
            "description",
            params.newValue,
          ),
      },

      {
        field: "team",
        headerName: "team",
        editable: true,
        filter: "agTextColumnFilter",
        floatingFilter: true,
        singleClickEdit: true,
        minWidth: 200,
        cellEditor: "agSelectCellEditor",
        cellEditorParams: { values: ["Select", ...team_OPTIONS] },
        cellRenderer: DropdownCellRenderer,
        valueFormatter: (params: { value: any }) => params.value || "Select",
        onCellValueChanged: (params: any) =>
          handleInputChange(
            {
              row_number: params.data.row_number,
              upload_datetime: params.data.upload_datetime,
              filename: params.data.filename,
              sub_name: params.data.sub_name,
            },
            "team",
            params.newValue,
          ),
        cellStyle: {
          fontSize: "13px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        },
      },

      {
        field: "reasons",
        headerName: "Reasons",
        editable: true,
        filter: "agTextColumnFilter",
        floatingFilter: true,
        singleClickEdit: true,
        minWidth: 200,
        cellEditor: "agSelectCellEditor",
        cellEditorParams: { values: ["Select", ...reasons_OPTIONS] },
        cellRenderer: DropdownCellRenderer,
        valueFormatter: (params: { value: any }) => params.value || "Select",
        onCellValueChanged: (params: any) =>
          handleInputChange(
            {
              row_number: params.data.row_number,
              upload_datetime: params.data.upload_datetime,
              filename: params.data.filename,
              sub_name: params.data.sub_name,
            },
            "reasons",
            params.newValue,
          ),
        cellStyle: {
          fontSize: "13px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        },
      },

      {
        field: "Name",
        headerName: "Name",
        editable: true,
        filter: "agTextColumnFilter",
        floatingFilter: true,
        singleClickEdit: true,
        minWidth: 200,
        cellEditor: "agSelectCellEditor",
        cellEditorParams: { values: ["Select", ...onlyNames] },
        cellRenderer: DropdownCellRenderer,
        valueFormatter: (params: { value: any }) => params.value || "Select",
        onCellValueChanged: (params: any) =>
          handleInputChange(
            {
              row_number: params.data.row_number,
              upload_datetime: params.data.upload_datetime,
              filename: params.data.filename,
              sub_name: params.data.sub_name,
            },
            "Name",
            params.newValue,
          ),
        cellStyle: {
          fontSize: "13px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        },
      },
    ];

    return [...baseColumns, ...editableColumns];
  }, [reduxData, onlyNames, handleInputChange]);

  const defaultColDef = useMemo(
    () => ({
      flex: 1,
      minWidth: 100,
      filter: true,
      sortable: true,
      resizable: true,
    }),
    [],
  );

  const visibleRows = useMemo(() => {
    const editableCols = ["invoiceId", "description", "team", "reasons", "Name"];

    if (!Array.isArray(dataId)) return [];

    const updatedRows: any[] = [];
    const pendingRows: any[] = [];

    dataId.forEach((row) => {
      const hasValue = editableCols.some((col) => row[col] && row[col].toString().trim() !== "");

      if (hasValue) updatedRows.push(row);
      else pendingRows.push(row);
    });

    //  Update counts properly
    setPendingCount(pendingRows.length);
    setUpdatedCount(updatedRows.length);

    console.log(updatedCount, "fhg");
    console.log(pendingCount, "ghj");
    // Return rows based on toggle
    return showEditable ? updatedRows : pendingRows;
  }, [dataId, showEditable]);

  useEffect(() => {
    if (!Array.isArray(data) || !Array.isArray(dataId)) return;

    const editableCols = ["invoiceId", "description", "team", "reasons", "Name"];

    // Unique comparison key
    const key = (r: any) => `${r.row_number}__${r.upload_datetime}__${r.filename}__${r.sub_name}`;

    // Prepare lookup map for dataId
    const dataIdMap = new Map(dataId.map((row) => [key(row), row]));

    const merged: any[] = [];

    // 1ï¸âƒ£ Merge existing UI data with updated rows
    for (const row of data) {
      const k = key(row);

      if (dataIdMap.has(k)) {
        const updatedRow = dataIdMap.get(k);

        // check if any editable column changed
        const changed = editableCols.some(
          (col) =>
            updatedRow[col] !== undefined &&
            updatedRow[col]?.toString().trim() !== "" &&
            updatedRow[col] !== row[col],
        );

        merged.push(changed ? updatedRow : row);

        dataIdMap.delete(k);
      } else {
        merged.push(row);
      }
    }

    // 2ï¸âƒ£ Remaining rows in dataId are NEW rows â†’ add them
    for (const newRow of dataIdMap.values()) {
      merged.push(newRow);
    }

    setFinalData(merged);
  }, [data, dataId]);

  const filteredData = useMemo(() => {
    if (!Array.isArray(finalData)) return [];

    const editableCols = ["invoiceId", "description", "team", "reasons", "Name"];

    const updated: any[] = [];
    const pending: any[] = [];

    finalData.forEach((row) => {
      const isUpdated = editableCols.some((col) => row[col] && row[col].toString().trim() !== "");

      if (isUpdated) updated.push(row);
      else pending.push(row);
    });

    setUpdatedCount(updated.length);
    setPendingCount(pending.length);

    return showEditable ? updated : pending;
  }, [finalData, showEditable]);

  console.log(data, "ddata");
  // console.log(visibleRows, "visibleRows-----------------");
  console.log(reduxData, "reduxData");
  console.log(dataId, "daatID");
  console.log(finalData, "finalData");

  return (
    <div className="min-h-screen  p-6">
      <div className="max-w-[95vw] mx-auto bg-white shadow-2xl rounded-2xl overflow-hidden">
        {/* HEADER */}
        <div className="border border-gray-200 px-6 py-4 flex items-center justify-between">
          {/* Left Section */}
          <div className="flex items-center gap-6">
            <h1 className="text-2xl font-bold text-black">Amex Records Management</h1>

            {/* Toggle Button */}
            <label className="relative inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={showEditable}
                onChange={() => setShowEditable((prev) => !prev)}
                className="sr-only peer"
              />
              <div className="w-44 h-10 bg-gray-200 rounded-full peer peer-checked:bg-purple-200 transition-colors duration-300 flex items-center"></div>
              <div className="absolute left-1 top-1/2 -translate-y-1/2 w-8 h-8 bg-purple-600 rounded-full transition-transform duration-300 ease-in-out peer-checked:translate-x-[136px] shadow-lg"></div>
              {/* Pending */}
              <span className="absolute left-11 top-1/2 -translate-y-1/2 text-sm font-semibold text-gray-700 pointer-events-none transition-opacity duration-300 peer-checked:opacity-0 whitespace-nowrap">
                Pending ({pendingCount})
              </span>
              {/* Updated */}
              <span className="absolute right-12 top-1/2 -translate-y-1/2 text-sm font-semibold text-gray-700 pointer-events-none opacity-0 transition-opacity duration-300 peer-checked:opacity-100 whitespace-nowrap">
                Updated ({updatedCount})
              </span>
            </label>
          </div>

          {/* Right Section */}
          <div className="flex items-center gap-4">
            <div className="rounded-xl px-4 py-2 bg-purple-100">
              <span className="text-sm font-medium text-gray-700">
                Total Records:{" "}
                <span className="font-bold text-purple-600">{finalData?.length || 0}</span>
              </span>
            </div>

            <button
              onClick={handleSubmitClick}
              disabled={isSaving}
              className="bg-purple-600 hover:bg-purple-800 rounded-xl text-white px-6 py-2.5 font-semibold transition-all duration-200 disabled:opacity-60 disabled:cursor-not-allowed hover:shadow-xl"
            >
              {isSaving ? "Submitting..." : "Submit Changes"}
            </button>
          </div>
        </div>

        {/* ERROR */}
        {error && (
          <div className="mx-6 mt-4 p-4 bg-red-50 border-l-4 border-red-500 text-red-700 rounded-lg shadow-sm">
            <div className="flex items-center">
              <svg className="w-5 h-5 mr-2" fill="currentColor" viewBox="0 0 20 20">
                <path
                  fillRule="evenodd"
                  d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z"
                  clipRule="evenodd"
                />
              </svg>
              {error}
            </div>
          </div>
        )}
        <span className="text-sm text-red-500 flex items-center text-center py-1 mt-2 justify-center">
          Save your edits â€” only saved rows move to Updated records. Unsaved changes will be lost,
          even if you refresh.
        </span>
        {/* LOADING */}
        {loading && <LoadingSpinner />}

        {/* AG GRID TABLE */}
        {!loading && finalData && finalData.length > 0 && (
          <div className="p-4">
            <div
              className="ag-theme-alpine rounded-xl overflow-hidden shadow-lg"
              style={{ height: "800px", width: "100%" }}
            >
              <AgGridReact
                ref={gridRef}
                // rowData={finalData}
                rowData={filteredData}
                columnDefs={columnDefs}
                animateRows={true}
                pagination={true}
                paginationPageSize={100}
                suppressHorizontalScroll={false}
                enableBrowserTooltips={true}
                suppressMovableColumns={false}
                rowSelection="multiple"
                theme="legacy"
                defaultColDef={defaultColDef}
              />
            </div>
          </div>
        )}

        {!loading && finalData && finalData.length === 0 && (
          <div className="text-center text-gray-500 py-20">
            <svg
              className="mx-auto h-12 w-12 text-gray-400 mb-4"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"
              />
            </svg>
            <p className="text-lg font-medium">No records found in dataset.</p>
          </div>
        )}
      </div>

      {/* Confirm modal */}
      <ConfirmModal
        open={isModalOpen}
        title="Save Confirmation"
        message={modalMessage}
        onConfirm={handleConfirmSave}
        onClose={() => setIsModalOpen(false)}
      />
    </div>
  );
};

export default RecordsFetch;







